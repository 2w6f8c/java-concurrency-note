# 第2章 并发编程的其他基础知识

##  并行与并发区别

并行指同一**时间段**多个任务同时都在进行，并且都没有执行结束，而并行是说在**单位时间**内多个任务在同时运行。

并发任务强调在一个时间段内同时进行，而一个时间段有多个单位i时间构成，所以说并发的多个任务在单位时间内不一定同时在执行。

一个CPU同时只能执行一个任务，所以单CPU时代多个任务都是并发执行的。

 >  注：在多线程时间中，线程的个数往往多于CPU个数，所以即使存在并行任务，一般还是称为多线程并发编程而非多线程并行编程。

## Java中的线程安全问题

示例：计数器问题

|       | t1                          | t2                          | t3                    | t4         |
| ----- | --------------------------- | --------------------------- | --------------------- | ---------- |
| 线程A | 从主内存读取count值到本线程 | 递增本地线程count的值       | 写回主内存            |            |
| 线程B |                             | 从主内存读取count值到本线程 | 递增本地线程count的值 | 写回主内存 |

假设count初始值为0，线程A在t1和t2时间读取了主内存中的count并在本地将其递增为1，t2时线程B从主内存中读取了count的值0并于t3时将其递增为1，t3时线程A将count的新值1更新到主内存，t4时线程B进行了同样的操作，最终主内存中count的值为2而非我们想要的3。

## Java中共享变量的内存可见性问题

![](/images/02.png)


如图是一个双核CPU模型，每个和都有自己的一级缓存，有些架构里还有一个所有CPU共享的二级缓存。

现假设线程A和线程B同时处理一个共享变量，由于Cache的存在，将会出现**内存不可见**问题，原因如下：

- 线程A先获取共享变量X的值（假设X=0），由于L1和L2缓存中都没有X的值，线程A会直接从主存中去取X的值并将其缓存到L1和L2中。然后A将X的值递增为1，将其写入缓存L1和L2，并刷新到主存。
- 线程B也要获取X的值，由于Core2中1级缓存没有X的值，B会从L2缓存取到X的值1。然后B修改X为2，将其更新至L1、L2和主存。
- 线程A又需要获取X的值，发现L1中已经有了，但此时A获得的X=1，与主存中X=2不同了！

## synchronized关键字

synchronized关键字是一种原子性内置锁，线程进入synchronized代码块前会自动获取监视器锁，这时其他线程再访问该同步代码块是会被阻塞挂起。

前面的共享变量内存可见性问题主要是线程的工作内存导致的，而synchronized的内存语义可以解决此问题。

synchronized的内存语义：
- 进入synchronized块的内存语义是把synchronized块中使用到的变量从线程的工作内存中清除，这样当synchronized块中要使用该变量时，就会从主存中去取。
- 离开synchronized块的内存语义是把synchronized块中对共享变量的修改刷新到主内存。

### 示例

```java
public class ThreadSafeInteger {

    private int value;

    public synchronized int get() {
        return value;
    }

    public synchronized void set(int value) {
        this.value = value;
    }
}
```

> 注1：get()方法虽然只是读操作，但仍要加上synchronized来实现value的内存可见性。
>
> 注2：使用synchronized虽然解决了共享变量value的内存可见性问题，但由于synchronized是独占锁，同时只能有一个线程调用get()方法，其他调用线程则会被阻塞，同时存在线程切换、调度的开销，效率并不高。

## volatile关键字

当一个变量声明为volatile时，线程在写入变量时就不会把值缓存，而是直接把值刷新到主存中；当其他线程读取该变量时，会从主存中重新获得最新值，而不是使用当前工作内存中的值。

### 示例

```java
public class ThreadSafeInteger {

    private volatile int value;

    public int get() {
        return value;
    }

    public void set(int value) {
        this.value = value;
    }
}
```

> 注：volatile虽然保证了可见性，但并不保证操作的原子性。

### volatile不保证原子性示例

```java
public class Test {
    
    private static volatile long _longVal = 0;

    public static void main(String[] args) {

        Thread t1 = new Thread(new LoopVolatile1());
        t1.start();

        Thread t2 = new Thread(new LoopVolatile2());
        t2.start();

        try{
            t1.join();
            t2.join();
        }catch(Exception e){
            e.printStackTrace();
        }


        System.out.println("final val is: " + _longVal);
    }

    private static class LoopVolatile1 implements Runnable {
        public void run() {
            long val = 0;
            while (val < 100000) {
                _longVal++;
                val++;
            }
        }
    }


    private static class LoopVolatile2 implements Runnable {
        public void run() {
            long val = 0;
            while (val < 100000) {
                _longVal++;
                val++;
            }
        }
    }
}
```

运行上述代码，发现每次输出不同。

### 使用场景

- 写入变量值不依赖当前值。如果依赖当前值，将是获取-计算-写入三步，这三步并非原子性，volatile也不保证原子性。
- 读写变量值时没有加锁。因为加锁本身已经保证了内存可见性，再使用volatile就是画蛇添足。



