##  并行与并发区别
<!-- TOC -->

- [并行与并发区别](#并行与并发区别)
- [Java中的线程安全问题](#java中的线程安全问题)
- [Java中共享变量的内存可见性问题](#java中共享变量的内存可见性问题)

<!-- /TOC -->
并行指同一**时间段**多个任务同时都在进行，并且都没有执行结束，而并行是说在**单位时间**内多个任务在同时运行

并发任务强调在一个时间段内同时进行，而一个时间段有多个单位i时间构成，所以说并发的多个任务在单位时间内不一定同时在执行

一个CPU同时只能执行一个任务，所以单CPU时代多个任务都是并发执行的

 >  注：在多线程时间中，线程的个数往往多于CPU个数，所以即使存在并行任务，一般还是称为多线程并发编程而非多线程并行编程

## Java中的线程安全问题

示例：计数器问题

|    |t1  |t2    |t3    |t4    |
|---------   |----------------------------------------|----------------------------------|-------------------|-------------------|
|线程A    |从主内存读取count值到本线程    |递增本地线程count的值    |写回主内存    |    |
|线程B    |    |从主内存读取count值到本线程    |递增本地线程count的值    |写回主内存    |

假设count初始值为0，线程A在t1和t2时间读取了主内存中的count并在本地将其递增为1，t2时线程B从主内存中读取了count的值0并于t3时将其递增为1，t3时线程A将count的新值1更新到主内存，t4时线程B进行了同样的操作，最终主内存中count的值为2而非我们想要的3

## Java中共享变量的内存可见性问题

![](/images/02.png)


如图是一个双核CPU模型，每个和都有自己的一级缓存，有些架构里还有一个所有CPU共享的二级缓存

现假设线程A和线程B同时处理一个共享变量，由于Cache的存在，将会出现**内存不可见**问题，原因如下：

- 线程A先获取共享变量X的值（假设X=0），由于L1和L2缓存中都没有X的值，线程A会直接从主存中去取X的值并将其缓存到L1和L2中。然后A将X的值递增为1，将其写入缓存L1和L2，并刷新到主存
- 线程B也要获取X的值，由于Core2中1级缓存没有X的值，B会从L2缓存取到X的值1。然后B修改X为2，将其更新至L1、L2和主存
- 线程A又需要获取X的值，发现L1中已经有了，但此时A获得的X=1，与主存中X=2不同了！
